Metadata-Version: 2.1
Name: pykalman
Version: 0.9.7
Summary: An implementation of the Kalman Filter, Kalman Smoother, and EM algorithm in Python
Author-email: Daniel Duckworth <pykalman@gmail.com>, Maksym Balatsko <mbalatsko@gmail.com>
License: All code contained except that in pykalman/utils.py is released under the
        license below. All code in pykalman/utils.py is released under the license
        contained therein.
        
        New BSD License
        
        Copyright (c) 2012 Daniel Duckworth.
        All rights reserved.
        
        
        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are met:
        
          a. Redistributions of source code must retain the above copyright notice,
             this list of conditions and the following disclaimer.
          b. Redistributions in binary form must reproduce the above copyright
             notice, this list of conditions and the following disclaimer in the
             documentation and/or other materials provided with the distribution.
          c. Neither the name of Daniel Duckworth nor the names of
             its contributors may be used to endorse or promote products
             derived from this software without specific prior written
             permission.
        
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
        SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
        DAMAGE.
        
Project-URL: Homepage, https://github.com/pykalman/pykalman
Project-URL: Repository, https://github.com/pykalman/pykalman
Project-URL: Documentation, https://pykalman.github.io/
Keywords: kalman filter,smoothing
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Requires-Python: >=3.6
Description-Content-Type: text/markdown
License-File: COPYING
Requires-Dist: numpy
Requires-Dist: scipy
Provides-Extra: all
Requires-Dist: pytest ; extra == 'all'
Requires-Dist: Sphinx ; extra == 'all'
Requires-Dist: numpydoc ; extra == 'all'
Requires-Dist: twine ; extra == 'all'
Provides-Extra: docs
Requires-Dist: Sphinx ; extra == 'docs'
Requires-Dist: numpydoc ; extra == 'docs'
Provides-Extra: tests
Requires-Dist: pytest ; extra == 'tests'

# pykalman

Welcome to `pykalman`, the dead-simple Kalman Filter, Kalman Smoother, and EM library for Python.

## Installation

For a quick installation::

```bash
pip install pykalman
```

Alternatively, you can setup from source:

```bash
pip install .
```

## Usage

``` python
from pykalman import KalmanFilter
import numpy as np
kf = KalmanFilter(transition_matrices = [[1, 1], [0, 1]], observation_matrices = [[0.1, 0.5], [-0.3, 0.0]])
measurements = np.asarray([[1,0], [0,0], [0,1]])  # 3 observations
kf = kf.em(measurements, n_iter=5)
(filtered_state_means, filtered_state_covariances) = kf.filter(measurements)
(smoothed_state_means, smoothed_state_covariances) = kf.smooth(measurements)
```

Also included is support for missing measurements:

```python
from numpy import ma
measurements = ma.asarray(measurements)
measurements[1] = ma.masked   # measurement at timestep 1 is unobserved
kf = kf.em(measurements, n_iter=5)
(filtered_state_means, filtered_state_covariances) = kf.filter(measurements)
(smoothed_state_means, smoothed_state_covariances) = kf.smooth(measurements)
```

And for the non-linear dynamics via the `UnscentedKalmanFilter`:

```python
from pykalman import UnscentedKalmanFilter
ukf = UnscentedKalmanFilter(lambda x, w: x + np.sin(w), lambda x, v: x + v, transition_covariance=0.1)
(filtered_state_means, filtered_state_covariances) = ukf.filter([0, 1, 2])
(smoothed_state_means, smoothed_state_covariances) = ukf.smooth([0, 1, 2])
```

And for online state estimation:

```python
 for t in range(1, 3):
    filtered_state_means[t], filtered_state_covariances[t] = \
            kf.filter_update(filtered_state_means[t-1], filtered_state_covariances[t-1], measurements[t])
```

And for numerically robust "square root" filters

```python
from pykalman.sqrt import CholeskyKalmanFilter, AdditiveUnscentedKalmanFilter
kf = CholeskyKalmanFilter(transition_matrices = [[1, 1], [0, 1]], observation_matrices = [[0.1, 0.5], [-0.3, 0.0]])
ukf = AdditiveUnscentedKalmanFilter(lambda x, w: x + np.sin(w), lambda x, v: x + v, observation_covariance=0.1)
```

## Examples

Examples of all of `pykalman`'s functionality can be found in the scripts in
the `examples/` folder.
